
import os
import shutil
from typing import BinaryIO

from fastapi import FastAPI, Depends, UploadFile, File, Header, Request, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse

from sqlalchemy.orm import Session
from . import models, schemas, utils, storage, config
from .database import engine, get_db

# Create the database tables automatically
models.Base.metadata.create_all(bind=engine)



app = FastAPI(title="Common Features API")

# Setup CORS (Cross-Origin Resource Sharing)
# This allows your React frontend (running on port 3000) to talk to this backend
origins = [
    "http://localhost:3000",
    "http://localhost:5173", # Vite default port
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
def read_root():
    return {"message": "Server is running successfully", "status": "ok"}

@app.post("/signup", response_model=schemas.UserResponse, status_code=status.HTTP_201_CREATED)
def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):
    
    # 1. Check if email already exists
    db_user = db.query(models.User).filter(models.User.email == user.email).first()
    if db_user:
        raise HTTPException(
            status_code=400, 
            detail="Email already registered"
        )
    
    # 2. Hash the password
    hashed_pwd = utils.hash_password(user.password)
    
    # 3. Create the DB Model instance
    new_user = models.User(
        username=user.username,
        email=user.email,
        hashed_password=hashed_pwd
    )
    
    # 4. Add to DB and Commit
    db.add(new_user)
    db.commit()
    db.refresh(new_user) # Refresh to get the ID generated by the DB
    
    return new_user
@app.post("/login", response_model=schemas.Token)
def login(user_credentials: schemas.UserLogin, db: Session = Depends(get_db)):
    
    # 1. Find the user by email
    user = db.query(models.User).filter(models.User.email == user_credentials.email).first()
    
    # 2. Check if user exists AND password matches
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, 
            detail="Invalid Credentials"
        )
    
    if not utils.verify_password(user_credentials.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, 
            detail="Invalid Credentials"
        )
    
    # 3. Create Access Token
    access_token = utils.create_access_token(data={"sub": user.email})
    
    return {"access_token": access_token, "token_type": "bearer"}

# --- VIDEO UPLOAD ENDPOINT ---
@app.post("/upload-video")
async def upload_video(file: UploadFile = File(...)):
    filename = await storage.save_video(file)    
    return {"filename": filename,"mode": config.STORAGE_MODE, "message": "Video uploaded successfully"}

# --- NEW: VIDEO STREAMING LOGIC ---

CHUNK_SIZE = 1024 * 1024  # 1MB chunks

def send_bytes_range_requests(
    file_obj: BinaryIO, start: int, end: int, chunk_size: int = 10_000
):
    """Generator to read file in chunks."""
    with file_obj as f:
        f.seek(start)
        while (pos := f.tell()) <= end:
            read_size = min(chunk_size, end + 1 - pos)
            yield f.read(read_size)

def _get_range_header(range_header: str, file_size: int) -> tuple[int, int]:
    """Parse the Range header to determine start and end bytes."""
    def _invalid_range():
        return HTTPException(
            status_code=status.HTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE,
            detail=f"Invalid Range Header (file size: {file_size})",
        )

    try:
        h = range_header.replace("bytes=", "").split("-")
        start = int(h[0]) if h[0] != "" else 0
        end = int(h[1]) if h[1] != "" else file_size - 1
    except ValueError:
        raise _invalid_range()

    if start > end or start >= file_size:
        raise _invalid_range()

    return start, min(end, file_size - 1)

# --- 2. HYBRID GET URL ENDPOINT ---
# The frontend calls this to know WHAT to play
@app.get("/video-url/{video_name}")
def get_video_play_url(video_name: str):
    url = storage.get_video_url(video_name)
    return {"video_url": url}


@app.get("/stream/{video_name}")
def stream_video_local(video_name: str, range: str = Header(None)):
    video_path = f"{config.UPLOAD_DIR}/{video_name}"
    
    # 1. Check if file exists
    if not os.path.exists(video_path):
        raise HTTPException(status_code=404, detail="Video not found")
    
    # 2. Get file size
    file_size = os.path.getsize(video_path)
    
    # 3. Handle Range Header (If browser requests a specific part)
    if range:
        start, end = _get_range_header(range, file_size)
        
        # Determine strict chunk size to avoid memory overload
        # We limit the response to 1MB per request typically
        chunk_end = min(end, start + CHUNK_SIZE - 1)
        
        headers = {
            "Content-Range": f"bytes {start}-{chunk_end}/{file_size}",
            "Accept-Ranges": "bytes",
            "Content-Length": str(chunk_end - start + 1),
            "Content-Type": "video/mp4",
        }
        
        return StreamingResponse(
            send_bytes_range_requests(open(video_path, "rb"), start, chunk_end),
            headers=headers,
            status_code=206, # 206 = Partial Content
        )
    
    # 4. If no range header, serve normally (fallback)
    return StreamingResponse(
        open(video_path, "rb"), 
        media_type="video/mp4"
    )

# --- NEW: LIST VIDEOS ENDPOINT ---
@app.get("/videos")
def get_video_list():
    """Returns a list of available video filenames."""
    videos = storage.list_videos()
    return {"videos": videos}